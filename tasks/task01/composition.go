package composition

import "fmt"

/*
Тип Human с полями Name - имя человека, представлен типом string
поле Age - возраст человека, представлен беззнаковым целым числом
*/
type Human struct {
	Name string
	Age  uint
}

/*
Метод Greet типа Human представляет экземпляр приёмник выводом в stdout по
имени и возрасту
*/
func (h Human) Greet() {
	fmt.Printf("Hello! My name is %s and I'm %d years old\n", h.Name, h.Age)
}

/*
Тип Action встраивает в себя тип Human с помощью композиции и таким образом
"наследует" все методы, делая их доступными "напрямую".
Пример:

		func main() {
		  act := Action{Human{"Bob", 8}}
	    act.Greet()
		}

>> Hello! My name is Bob and I'm 8 years old

Такой тип встраивания удобен, в случая когда "дочерний" тип не переопределяет
"родительские" методы, или не имеет одноимённых методов. Иначе возможна
коллизия имён и в таком случае программа не скомпилируется. Для избежания этой
проблемы следует испольщовать другой подход. описанный типом Action2
*/
type Action struct {
	Human
}

/*
Тип Action2 решает проблему, имеющуюся в типе Action тем, что не встраивает тип
Human в себя полностью, а содержит его в себе как отдельное поле. Таким образом
функционал Human становится доступен в Action2, но через дополнительный
"спецификатор" при обращении к методу. Пример:

	func main() {
		act := Action2{Human{"Bob", 8}}
		act.Person.Greet()
	}

>> Hello! My name is Bob and I'm 8 years old

Такой способ выглядит более "нагруженным", но зато решает проблему коллизии
имён и тип Action2 таким образом может спокойно переопределять и обозначать
собственные одноимённые методы.
*/
type Action2 struct {
	Person Human
}
