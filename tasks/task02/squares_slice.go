package squeares_slice

import (
	"fmt"
	"sync"
)

/*
Данный вариант функции использует канал типа int с буфером соответствуюшим по
размеру количеству элементов изначального массива для передачи квадратов чисел
из дополнительных горутин. Первый цикл, перебирает все элементы
изначального массива. На каждой итерации в отдельной горутине запускается
анонимная функция, копирующая текущий элемент массива и записывающая квадрат
этого элемента в канал. После завершения цикла создаётся слайс для результатов
вычислений и в цикле в каждый элемент результирующего слайса записывается
значение, прочитанное из канала.
Буфер в канале в данном случае нужен для того чтобы при записи в канал горутина
не блокировалась до того момента пока из канала не будет прочитано
отправленное значение, а выполнялась дальше. Цикл с записью результатов в свою
очередь обеспечивает то что все запущенные в первом цикле горутины выполнятся до
завершения основной функции так как количество операций чтения равно количеству
операций записи в канал а следовательно и количеству горутин потому что
количество итераций первого и второго цикла равны друг-другу.

В первом цикле важно передавать в анонимную функцию текующий элемент слайса
именно по значению, то есть копируя его, так как время и очередь выполнения
запускаемой горутины ничем не гарантированы и передача значения элемента по
ссылке приведёт к неопределённому результату - переменная num может быть равна
любому элементу изначального слайса, либо же цикл может завершиться к моменту
выполнения горутины и такой переменной может попросту больше не существовать.

Недостатком данного варианта является то что порядок вывода элементов не
гарантирован опять же из-за того что порядок и время выполнения горутин могут
быть любыми.
*/
func SquareSliceCh(nums []int) []int {
	results := make(chan int, len(nums))

	for _, num := range nums {
		go func(num int, results chan<- int) {
			results <- num * num
		}(num, results)
	}

	res := make([]int, len(nums))

	for i := 0; i < len(res); i++ {
		res[i] = <-results
		fmt.Printf("%d ", res[i])
	}
	fmt.Print("\n")

	return res
}

/*
Данный вариант в деталях передачи данных в горутину аналогичен предыдущему, но
вместо канала как гаранта выполнения всех горутин использует WaitGroup -
специальную структуру для синхронизации выполнения горутин. В упрощённом
изложении WaitGroup является счётчиком горутин с методами Add - инкремент
счётчика на указанное количество, Done - декремент счётчика на 1 значение и
Wait - блокирование горутины до тех пор, пока счётчик не станет равен 0. Таким
образом при старте горутины следует увеличивать счётчик на один (или же если
количество необходимых горутин заранее известно - можно увеличить счётчик
сразу на это количество (как в данном примере)), по завершению горутины
уменьшать счётчик и в моменте, после которого все горутины должны завершиться -
заблокировать горутину до тех пор пока счётчик не станет равен 0.

Ещё одно отличие данного варианта - сохранение порядка элементов оригинального
слайса - результирующий слайс создаётся до первого цикла и сразу аллоцируется
необходимое количество памяти. Затем, в цикле при запуске горутины, помимо числа,
которое следует возвести в квадрат, в горутину передаётся так же индекс числа в
массиве и результат вычисления записывается на своё место в результирующем
слайсе. Так же запись каждого элемента на своё место исключает возникновение
состояния гонки, так как каждая горутина пишет в свою ячейку памяти.
*/
func SquareSliceWG(nums []int) []int {
	var wg sync.WaitGroup
	wg.Add(len(nums))

	res := make([]int, len(nums))

	for i, num := range nums {
		go func(i, num int) {
			res[i] = num * num
			wg.Done()
		}(i, num)
	}
	wg.Wait()

	for _, num := range res {
		fmt.Printf("%d ", num)
	}
	fmt.Print("\n")

	return res
}

/*
Я бы предпочёл первый вариант в случае когда не требуется сохранение
изначального порядка элементов. Использование каналов мне кажется более
изящным и в частном случае этого варианта - "основная" горутина меньше "спит".
Сразу после завершения первого цикла программа переходит к чтению данных из
канала, не дожидаясь пока все дополнительные горутины завершатся.

Поэтому можно реализовать ещё один вариант, использующий канал исключительно
для синхронизации, а не передачи результатов вычислений. Квадраты же будем
записывать по индексам сразу в первом цикле.
*/
func SquareSliceChOrdered(nums []int) []int {
	res := make([]int, len(nums))
	syncChan := make(chan bool, len(nums))
	for i, num := range nums {
		go func(i, num int, sync chan<- bool) {
			res[i] = num * num
			sync <- true
		}(i, num, syncChan)
	}

	for range nums {
		<-syncChan
	}

	for _, num := range res {
		fmt.Printf("%d ", num)
	}
	fmt.Print("\n")

	return res
}

func SquareSliceMu(nums []int) []int {
	var wg sync.WaitGroup
	var mu sync.Mutex
	res := make([]int, 0)

	wg.Add(len(nums))
	for _, num := range nums {
		go func(num int) {
			mu.Lock()
			res = append(res, num*num)
			mu.Unlock()
			wg.Done()
		}(num)
	}
	wg.Wait()

	for _, num := range res {
		fmt.Printf("%d ", num)
	}
	fmt.Print("\n")

	return res
}

/*
однако интуиция подвела меня. проведя тестирование с помощью встроенного в язык
бенчмарка я получил следующие результаты для всех функций:

❯ go test -bench="." -benchmem -run="kw"
goos: darwin
goarch: amd64
pkg: wb01/tasks/task02
cpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz
BenchmarkSquareSliceChan-8          	  116328	     10337 ns/op	     944 B/op	      21 allocs/op
BenchmarkSquareSliceWG-8            	  132080	      7608 ns/op	    1536 B/op	      38 allocs/op
BenchmarkSquareSliceChanOrdered-8   	   91666	     11534 ns/op	    1648 B/op	      38 allocs/op
BenchmarkSquareSliceMu-8            	  137760	      8655 ns/op	    1520 B/op	      45 allocs/op
PASS
ok  	wb01/tasks/task02	7.709s

как видно - варианты используюшие WaitGroup и Mutex на порядок быстрее обоих
вариантов, использующих канал для синхронизации, либо же передачи данных. и
обусловлено это тем, что канал не является некой магической сущностью, решающей
все проблемы синхронизации и обмена данными между горутинами, а есть всего
навсего надстройка над мьютексом, включающей в себя информацию о типе данных,
которые канал передает и несколько счётчиков и очередей для передаваемых
элементов.
Но хоть одно преимущество есть у первого варианта - ощутимо меньшие
использование памяти и количество аллокаций)
*/
