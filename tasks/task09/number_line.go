package main

import "fmt"

/*
WriteToChan принимает числа через канал recv числа из массива и отправляет эти
числа удваивая их в канал send. чтение из канала происходит в цикле for range
которая при очередном считывании проверяет, что канал не был закрыт и в
противном случае завершает цикл, после чего закрывает канал, в который
записывались удовоенные чилса из канала recv.
*/
func WriteToChan(recv <-chan int, send chan<- int) {
	for num := range recv {
		send <- num * 2
	}
	close(send)
}

/*
RecvFromChan принимает числа из канала и выводит их в stdout, чтение происходит
внутри цикла for range по каналу, который завершается после закрытия канала.
*/
func RecvFromChan(recv <-chan int) {
	for num := range recv {
		fmt.Println(num)
	}
}

/*
в main функции создаётся слайс чисел для удвоения и отправления их в канал,
после чего создаются два канала - sender с буфером в количество элементов слайса
для последующих удвоения и отправки их в небуферизированный канал reciever.
наличие буфера в канале sender необходимо для того чтобы при последюущем запуске
функции WriteToChan в отдельной горутине не возникло дедлока - состояния когда
все запущенные горутины ждут либо чтения, либо записи в канал. отсутсвие же
буфера в канале reciever необходимо для синхронизации горутин - чтобы
WriteToChan успела удвоить и записать все значения из массива в reciever до
завершения "основной", запустившей её горутины.
*/
func main() {
	nums := []int{1, 2, 3, 4, 5, 6, 7, 8}
	sender := make(chan int, len(nums))
	reciever := make(chan int)

	go WriteToChan(sender, reciever)

	for _, num := range nums {
		sender <- num
	}
	close(sender)

	RecvFromChan(reciever)
}
