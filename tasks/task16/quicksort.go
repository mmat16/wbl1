package main

import (
	"fmt"
	"math/rand"

	"golang.org/x/exp/constraints"
)

/*
Quicksort реализует алгоритм быстрой сортировки при помощи рекурсии. Базовым
случаем тут является ситуация когда слайс пуст, либо содержит ровно 1 элемент,
так как сортировка таких слайсов не имеет смысла.
После проверки базового случая выставляются "указатели" (индексы) первого и
последнего элементов слайса и назначается опорный элемент алгоритма (в данной
реализации определяется случайным образом - существуют другие подходы, которые
сейчас рассмотренны не будут).
далее опорный и правый (последний) элементы меняются местами и запускается цикл
по всем элементам слайса. на каждой итерации проверяется что текущий элемент
меньше "правого" (на самом деле опорного - так как на предыдущем шаге они
поменялись местами) и если это условие выполняется, то текущий элемент меняется
местами с крайним "левым" элементом и индекс "левого" элемента инкрементируется:
таким образом все элементы, меньшие опорного оказываются слева.
следующим шагом происходит смена места "левого" и "правого" (опорного) элементов
и таким образом опорный элемент оказывается "за" (правее) "левой" ("меньшей")
части слайса.
после этого происходит два рекурсивных возова - для среза слайса от начала до
"левого" элемента и от следующего за "левым" до конца слайса. рекурсия
до наступления базового случая - когда исходный слайс оказывается разбит
вызовами на слайсы по 1 элементу, которые если собрать воедино образуют
отсортированный массив.
*/
func Quicksort[T constraints.Ordered](arr []T) []T {
	if len(arr) < 2 {
		return arr
	}
	left, right := 0, len(arr)-1
	pivot := rand.Int() % len(arr)

	arr[pivot], arr[right] = arr[right], arr[pivot]

	for i := range arr {
		if arr[i] < arr[right] {
			arr[i], arr[left] = arr[left], arr[i]
			left++
		}
	}

	arr[left], arr[right] = arr[right], arr[left]
	Quicksort(arr[:left])
	Quicksort(arr[left+1:])
	return arr
}

func main() {
	arr := []int{5, 235, 1, -124, 44, 3, 89, 0}
	fmt.Println(Quicksort(arr))
}
