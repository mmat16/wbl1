package main

import (
	"fmt"
	"math/rand"

	"golang.org/x/exp/slices"
)

/*
BinarySearch выполняет бинарный поиск в слайсе целых чисел, который перед
началом поиска соритруется, так как алгоритм бинарного поиска работает только
на отсортированных последовательнастях чисел. далее объявляются границы поиска,
которые на первой итерации представляют индексы левой и правой границ слайса.
затем запускается цикл с условием "индекс левой границы меньше или равен индексу
правой границы". на каждой итерации берётся индекс посередине между правим и
левым индексами и элемент по этому индексу проверяется на равенство искомому.
если это условие выполняется - поиск завершён и индекс элемента вместе с флагом
true. в противном случае проверяется - если срединный элемент больше искомого,
то поиск продолжается в срезе слайса от левой границы до середины от текущего
среза - 1 (правая граница перемещается на один элемент левее серединного индекса
), иначе перемещается левая граница - на следующий индекс после серединного.
в случае если цикл завершился, а элемент не был найден, функция возвращает ноль
и флаг false
*/
func BinarySearch(arr []int, elem int) (int, bool) {
	slices.Sort(arr)
	lo, hi := 0, len(arr)-1

	for lo <= hi {
		mid := (lo + hi) / 2

		if arr[mid] == elem {
			return mid, true
		}

		if arr[mid] > elem {
			hi = mid - 1
		} else {
			lo = mid + 1
		}
	}

	return 0, false
}

func main() {
	elemsCount := 4096
	elems := make([]int, elemsCount)

	for i := range elems {
		elems[i] = rand.Int()
	}

	pos, found := BinarySearch(elems, elems[rand.Int()%elemsCount])
	fmt.Println("found", found, "on position", pos)

	elems = []int{1, -142, 428, 32989, -23598, 4, 3, 1}

	pos, found = BinarySearch(elems, -5)
	fmt.Println("found", found, "on position", pos)
}
